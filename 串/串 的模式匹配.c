#define _CRT_SECURE_NO_WARNINGS 1

#include<stdio.h>

// 1. 朴素模式匹配算法
 
// Index(S,T) 定位操作的使用
//用于在字符串S中查找子串T的出现位置，返回子串T在字符串S中第一次出现的位置。
int Index(SString S, SString T)
{
	int k = 1;              // 初始化子串T在字符串S中的起始位置k为1。
	int i = k, j = 1;       // 初始化在字符串S中匹配子串T的位置i为k，初始化在子串T中匹配的位置j为1。
	while (i<=S.length && j<T.length)      // 判断i是否已经超出字符串S的范围，同时判断j是否已经超出子串T的范围，如果有一个条件不满足则停止循环。
	{
		if (S.ch[i] == T.ch[j])       // 比较字符串S中第i个字符和子串T中第j个字符是否相等，如果相等则将i和j分别加1。
		{
			++i;
			++j;
		}
		else    // 如果字符串S中第i个字符和子串T中第j个字符不相等，则表示当前位置不是匹配位置，需要将起始位置k右移一位，从下一个位置重新开始匹配。
		{
			k++;       // 将起始位置k加1，同时将i更新为k，j更新为1，表示在字符串S中从起始位置k + 1开始匹配子串T。
			i = k;
			j = 1;
		}
	}
	if (j > T.length)  // 判断子串T是否已经被完全匹配
		return k;      // 如果子串T已经被完全匹配，则返回在字符串S中匹配子串T的起始位置k。
	else
		return 0;      // 如果子串T未被完全匹配，则表示未找到匹配子串T，返回0表示未找到。
}

//总体来说，这段代码通过循环遍历字符串S和子串T，逐个字符进行比较，直到找到匹配子串T或者字符串S遍历完毕。
//该算法的时间复杂度为O(m * n)，其中m为字符串S的长度，n为子串T的长度，因此在处理大规模字符串匹配问题时，效率较低，但是在处理小规模问题时，该算法是一种简单、易于实现且效率较高的字符串匹配算法。





// 2. KMP算法
 
// 用于在字符串S中查找子串T的出现位置，并返回子串T在字符串S中第一次出现的位置。
int kmpIndex(SString S, SString T, int* next) 
{
	int i = 1, j = 1;     // 初始化i为1，表示在字符串S中从第一个位置开始，初始化j为1，表示在子串T中从第一个位置开始匹配。
	while (i <= S.length && j <= T.length) 
	{
		if (j == 0 || S.ch[i] == T.ch[j]) 
		{
			++i;
			++j;
		}
		else     // 不相等，则需要将j更新为next[j]，表示在子串T的第j个位置之前的最长公共前后缀的长度为next[j](此处可以理解为模式串向右移动)，继续尝试在字符串S中匹配子串T。
		{
			j = next[j];
		}
	}
	if (j > T.length) 
	{
		return i - T.length;
	}
	else 
	{
		return 0;
	}
}


// 函数kmpIndex是利用next数组，在字符串S中查找子串T的出现位置。
// 该算法的时间复杂度为O(m+n)，其中m为字符串S的长度，n为子串T的长度，因此在处理大规模字符串匹配问题时，效率相对于朴素模式匹配算法较高。


// 如何计算子串T的next数组?












